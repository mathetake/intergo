package om

import (
	"math"
	"math/rand"
	"sync"
	"time"

	"github.com/mathetake/intergo"
	"github.com/pkg/errors"
)

type OptimizedMultiLeaving struct {
	NumSampling int
}

var _ intergo.Interleaving = &OptimizedMultiLeaving{}

func init() {
	rand.Seed(time.Now().UnixNano())
}

// GetInterleavedRanking ... get a Interleaved ranking sampled from a set of interleaved rankings
// generated by `prefixConstraintSampling` method.
// Note that the way of the sampling is different from the original paper [Schuth, Anne, et al.,2014]
// where they solved LP with the unbiased constraint.
// We omit the unbiased constraint and only take `sensitivity` into account. Then we sample a ranking
// according to calculated sensitivities defined by equation (1) in [Manabe, Tomohiro, et al., 2017]
func (o *OptimizedMultiLeaving) GetInterleavedRanking(num int, rks ...intergo.Ranking) ([]intergo.Res, error) {
	if num < 1 {
		return nil, errors.Errorf("invalid NumSampling: %d", o.NumSampling)
	}

	var wg sync.WaitGroup
	cRks := make([][]intergo.Res, o.NumSampling)
	for i := 0; i < o.NumSampling; i++ {
		wg.Add(1)
		go func(i int) {
			cRks[i] = o.prefixConstraintSampling(num, rks...)
			wg.Done()
		}(i)
	}
	wg.Wait()

	// calc Insensitivity of sampled rankings
	ins := o.calcInsensitivities(rks, cRks)

	// init +inf value
	min := math.Inf(0)
	var maxIDx int
	for i, v := range ins {
		if v < min {
			maxIDx, min = i, v
		}
	}
	return cRks[maxIDx], nil
}

func (*OptimizedMultiLeaving) CalcInsensitivity(rks []intergo.Ranking, res []intergo.Res) float64 {
	var iRkNum = len(rks)
	var mean float64

	jToScoreMap := make([]float64, iRkNum)
	for i := 0; i < iRkNum; i++ {
		idToPlacement := map[interface{}]int{}
		for j := 0; j < rks[i].Len(); j++ {
			itemId := rks[i].GetIDByIndex(j)
			idToPlacement[itemId] = j + 1
		}
		for j := 0; j < len(res); j++ {
			var s = 1 / float64(j+1)
			var credit float64
			itemId := rks[res[j].RankingIDx].GetIDByIndex(res[j].ItemIDx)
			placement, ok := idToPlacement[itemId]
			if ok {
				credit = 1 / float64(placement)
			} else {
				credit = 1 / float64(rks[i].Len()+1)
			}
			ss := s * credit
			jToScoreMap[i] += ss
			mean += ss
		}
	}

	mean /= float64(iRkNum)
	var score float64
	for i := 0; i < iRkNum; i++ {
		var s = jToScoreMap[i] - mean
		score += s * s
	}
	return score
}

func (o *OptimizedMultiLeaving) calcInsensitivities(rks []intergo.Ranking, cRks [][]intergo.Res) []float64 {
	res := make([]float64, len(cRks))

	var wg sync.WaitGroup

	for k := 0; k < len(cRks); k++ {
		wg.Add(1)
		go func(k int) {
			res[k] = o.CalcInsensitivity(rks, cRks[k])
			wg.Done()
		}(k)
	}
	wg.Wait()
	return res
}

func (*OptimizedMultiLeaving) prefixConstraintSampling(num int, rks ...intergo.Ranking) []intergo.Res {
	var numR = len(rks)
	res := make([]intergo.Res, 0, num)

	// sIDs stores item's ID in order to prevent duplication in the generated list.
	sIDs := map[interface{}]interface{}{}

	// The fact that the index stored in usedUpRks means it is already used up.
	usedUpRks := map[int]bool{}

	for len(res) < num && len(usedUpRks) != numR {

		// chose randomly one ranking from the ones used up yet
		var selectedRkIdx = rand.Intn(numR)
		if _, ok := usedUpRks[selectedRkIdx]; ok {
			continue
		}

		var rk = rks[selectedRkIdx]
		var bef = len(res)
		for j := 0; j < rk.Len(); j++ {
			if _, ok := sIDs[rk.GetIDByIndex(j)]; !ok {
				res = append(res, intergo.Res{
					RankingIDx: selectedRkIdx,
					ItemIDx:    j,
				})
				sIDs[rk.GetIDByIndex(j)] = true
				break
			}
		}

		if len(res) == bef {
			usedUpRks[selectedRkIdx] = true
		}
	}
	return res
}
